<!doctype html>
<html lang="sl">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>PDFme Editor (Railway)</title>
    <style>
      html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; }
      /* 1. vrstica: ime + akcije */
      #topbar { display: flex; gap: 8px; align-items: center; padding: 8px 12px; border-bottom: 1px solid #e5e7eb; position: sticky; top: 0; background: #fff; z-index: 5; flex-wrap: wrap; }
      #nameWrap { display: flex; align-items: center; gap: 8px; }
      #tplName { min-width: 260px; }
      /* 2. vrstica: Base PDFs v eni vrstici */
      #subbar { display: flex; gap: 16px; align-items: center; padding: 8px 12px; border-bottom: 1px solid #e5e7eb; background: #fafafa; flex-wrap: wrap; }
      .baseGroup { display: flex; align-items: center; gap: 8px; }
      .label { font-size: 13px; color: #374151; min-width: 90px; }
      .badge { font-size: 12px; padding: 2px 6px; background: #eef2ff; border: 1px solid #c7d2fe; border-radius: 999px; }
      .warn  { background: #fff7ed; border-color: #fed7aa; }
      .good  { background: #ecfdf5; border-color: #bbf7d0; }
      .filehint { font-size: 12px; color: #6b7280; }
      .spacer { flex: 1; }
      .muted { color: #6b7280; font-size: 12px; }
      #mainWrap { display: flex; height: calc(100% - 116px); align-items: stretch; }
      #container { flex: 1; min-width: 0; }
      #varsPanel { width: 280px; border-left: 1px solid #e5e7eb; background: #f9fafb; display: flex; flex-direction: column; gap: 8px; padding: 12px; overflow-y: auto; }
      #varsPanel.hidden { display: none; }
      .varsHeader { display: flex; align-items: center; justify-content: space-between; gap: 8px; }
      .varsButtons { display: flex; gap: 6px; flex-shrink: 0; }
      #varsSearch { width: 100%; box-sizing: border-box; }
      #varsList { display: flex; flex-direction: column; gap: 6px; }
      .varsItem { text-align: left; background: #fff; border: 1px solid #e5e7eb; border-radius: 6px; padding: 6px 8px; cursor: pointer; display: flex; flex-direction: column; gap: 4px; }
      .varsItem:hover { border-color: #c7d2fe; background: #eef2ff; }
      .varsPath { font-family: ui-monospace, SFMono-Regular, SFMono, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace; font-size: 12px; }
      .varsValue { color: #6b7280; font-size: 12px; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; }
      #varsMeta, #varsCopyInfo, #varsEmpty { font-size: 12px; color: #6b7280; }
      button { padding: 8px 12px; border: 1px solid #ddd; border-radius: 8px; background: #fafafa; cursor: pointer; }
      input, select { padding: 6px 8px; border: 1px solid #ddd; border-radius: 8px; }
      #err { display:none; padding:10px 12px; color:#991b1b; background:#fef2f2; border:1px solid #fecaca; }
    </style>
  </head>
  <body>
    <div id="err"></div>

    <!-- Vrstica 1 -->
    <div id="topbar">
      <strong>PDFme Editor</strong>

      <div id="nameWrap">
        <span class="label">Name:</span>
        <input id="tplName" placeholder="Template name" />
      </div>

      <button id="btnNew">New</button>
      <button id="btnSave">Save</button>
      <button id="btnSaveAs">Save As</button>
      <button id="btnDuplicate" style="background:#f0f9ff;border-color:#bae6fd">Duplicate</button>
      <button id="btnDelete" style="background:#fff5f5;border-color:#f5c2c2">Delete</button>
      <button id="btnPreview">Preview</button>

      <span class="spacer"></span>

      <select id="tplList" style="min-width:320px"></select>
      <button id="btnLoad" style="display:none">Load</button>

      <button id="btnSetToken">Set Token</button>
      <button id="btnLogout" style="display:none">Logout</button>

      <div class="muted">Current ID: <span id="currentId">(none)</span></div>
    </div>

    <!-- Vrstica 2 -->
    <div id="subbar">
      <div class="baseGroup">
        <span class="label">Page 1 base:</span>
        <input type="file" id="base1File" accept="application/pdf" />
        <button id="btnBase1Upload">Upload</button>
        <button id="btnBase1Clear">Clear</button>
        <button id="btnBase1Download">Download</button>
        <span id="base1Status" class="badge warn">not set</span>
      </div>

      <div class="baseGroup">
        <span class="label">Page 2+ base:</span>
        <input type="file" id="base2File" accept="application/pdf" />
        <button id="btnBase2Upload">Upload</button>
        <button id="btnBase2Clear">Clear</button>
        <button id="btnBase2Download">Download</button>
        <span id="base2Status" class="badge warn">not set</span>
      </div>

      <div class="filehint">ƒåe dokument prese≈æe 1 stran, se na vseh naslednjih straneh uporabi Page&nbsp;2+ base.</div>

      <!-- Page Layout Switch (shows when Page 2+ base is set) -->
      <div id="pageLayoutSwitch" class="baseGroup" style="border-left: 2px solid #ddd; padding-left: 12px; margin-left: 12px; display: none;">
        <span class="label">Edit Layout:</span>
        <button id="btnEditPage1" style="background:#dbeafe;border-color:#93c5fd;padding:6px 12px;font-size:13px;">
          üìÑ Page 1
        </button>
        <button id="btnEditPage2" style="background:#e0e7ff;border-color:#c7d2fe;padding:6px 12px;font-size:13px;">
          üìë Page 2+
        </button>
        <span id="currentPageIndicator" style="font-size: 12px; color: #059669; background: #d1fae5; padding: 4px 8px; border-radius: 4px; margin-left: 8px;">
          Editing: Page 1
        </span>
      </div>
    </div>

    <div id="mainWrap">
      <div id="container"></div>
      <aside id="varsPanel">
        <div class="varsHeader">
          <div>
            <strong>Variables</strong>
            <div id="varsMeta" class="muted"></div>
          </div>
          <div class="varsButtons">
            <button id="btnSetSample" type="button">Set JSON</button>
            <button id="btnClearSample" type="button">Clear</button>
          </div>
        </div>

        <!-- Template Variables Detection -->
        <div style="background:#f0fdf4;border:1px solid #bbf7d0;padding:8px;border-radius:6px;margin-bottom:10px;">
          <div style="font-weight:600;font-size:13px;margin-bottom:4px;">üìã Template Variables</div>
          <div id="detectedVars" style="font-size:12px;color:#166534;margin-bottom:6px;min-height:20px;">
            No variables detected yet
          </div>
          <div style="display:flex;gap:6px;flex-wrap:wrap;">
            <button id="btnDetectVars" type="button" style="font-size:12px;padding:4px 8px;background:#dcfce7;border:1px solid #86efac;">
              üîç Detect Variables
            </button>
            <button id="btnCopyN8nConfig" type="button" style="font-size:12px;padding:4px 8px;background:#dbeafe;border:1px solid #93c5fd;" disabled>
              üìã Copy n8n Config
            </button>
            <button id="btnQuickAiField" type="button" style="font-size:12px;padding:4px 8px;background:#fef3c7;border:1px solid #fde047;">
              ‚ö° Quick Add AI Field
            </button>
          </div>
        </div>

        <div class="muted">Click a variable to copy <code>{{value}}</code>, or use "Detect Variables" to see all variables in template.</div>
        <input id="varsSearch" type="search" placeholder="Search..." />
        <div id="varsCopyInfo"></div>
        <div id="varsEmpty" class="muted">Paste sample JSON to list placeholders.</div>
        <div id="varsList"></div>
      </aside>
    </div>

    <script type="module">
      // ===== Helper za napake =====
      const showErr = (e) => {
        const box = document.getElementById('err');
        box.style.display = 'block';
        box.textContent = 'Error: ' + (e?.message || e);
        console.error(e);
      };

      // ===== Dinamiƒçni in robustni loaderji =====
      async function importFirstOk(urls) {
        let lastErr;
        for (const url of urls) {
          try { return await import(url); }
          catch (e) { console.warn('Import failed:', url, e); lastErr = e; }
        }
        throw lastErr || new Error('All imports failed');
      }

      async function loadUIAndCommon() {
        const uiMod     = await importFirstOk([
          'https://esm.sh/@pdfme/ui@5?bundle&target=es2020'
        ]);
        const commonMod = await importFirstOk([
          'https://esm.sh/@pdfme/common@5?bundle&target=es2020'
        ]);
        return { uiMod, commonMod };
      }

      async function loadSchemas() {
        const mod = await importFirstOk([
          'https://esm.sh/@pdfme/schemas@5?bundle&target=es2020',
          'https://unpkg.com/@pdfme/schemas@5/dist/index.es.js?module',
          'https://cdn.jsdelivr.net/npm/@pdfme/schemas@5/dist/index.es.js'
        ]);
        const S = (mod?.default ?? mod);
        const P = S.plugins ?? S;

        const pluginsRaw = {
          // besedila
          text: P.text,
          multiVariableText: P.multiVariableText,

          // grafika / oblike
          image: P.image,
          line: P.line,
          rectangle: P.rectangle,
          ellipse: P.ellipse,
          svg: P.svg,

          // tabela in form elementi
          table: P.table,
          select: P.select,
          date: P.date,
          time: P.time,
          dateTime: P.dateTime,
          radioGroup: P.radioGroup,
          checkbox: P.checkbox,

          // bar kode (mno≈æina: barcodes)
          qrcode: P.barcodes?.qrcode ?? P.qrcode,
          ean13: P.barcodes?.ean13 ?? P.ean13,
          ean8: P.barcodes?.ean8 ?? P.ean8,
          code39: P.barcodes?.code39 ?? P.code39,
          code128: P.barcodes?.code128 ?? P.code128,
          itf14: P.barcodes?.itf14 ?? P.itf14,
          nw7: P.barcodes?.nw7 ?? P.nw7,
          upca: P.barcodes?.upca ?? P.upca,
          upce: P.barcodes?.upce ?? P.upce,
          japanpost: P.barcodes?.japanpost ?? P.japanpost,
          gs1datamatrix: P.barcodes?.gs1datamatrix ?? P.gs1datamatrix,
          pdf417: P.barcodes?.pdf417 ?? P.pdf417,
        };

        // odstrani undefined
        const plugins = Object.fromEntries(Object.entries(pluginsRaw).filter(([,v]) => !!v));

        if (!plugins.text || !plugins.image) {
          throw new Error('Missing core plugins (text/image).');
        }
        return plugins;
      }

      // Load custom fonts from server
      async function loadCustomFonts() {
        try {
          const fontListRes = await fetch('/fonts/fonts.json');
          if (!fontListRes.ok) {
            console.log('[FONTS] No fonts.json found, using default fonts');
            return {};
          }

          // Check if response is actually JSON
          const contentType = fontListRes.headers.get('content-type');
          if (!contentType || !contentType.includes('application/json')) {
            console.log('[FONTS] fonts.json not found or not JSON, using default fonts');
            return {};
          }

          const fontConfig = await fontListRes.json();
          const fonts = {};
          let fallbackSet = false;

          for (const [fontName, fontPath] of Object.entries(fontConfig)) {
            console.log(`[FONTS] Loading ${fontName} from ${fontPath}...`);

            // Fetch font file and read as ArrayBuffer (required by PDFme)
            try {
              const fontRes = await fetch(`/fonts/${fontPath}`);
              if (fontRes.ok) {
                const fontData = await fontRes.arrayBuffer();

                // First valid font becomes fallback
                const isFallback = !fallbackSet;
                fonts[fontName] = {
                  data: fontData,  // Binary ArrayBuffer required by PDFme
                  fallback: isFallback
                };
                if (isFallback) {
                  fallbackSet = true;
                  console.log(`[FONTS] Set ${fontName} as fallback font`);
                }
                console.log(`[FONTS] Loaded ${fontName} (${(fontData.byteLength / 1024).toFixed(1)}KB)`);
              } else {
                console.warn(`[FONTS] Font file not accessible: ${fontPath} (${fontRes.status})`);
              }
            } catch (err) {
              console.warn(`[FONTS] Failed to load font: ${fontPath}`, err);
            }
          }

          // If no fonts loaded, return empty object (PDFme will use default)
          if (Object.keys(fonts).length === 0) {
            console.log('[FONTS] No valid fonts found, using PDFme defaults');
            return {};
          }

          // Ensure exactly one font has fallback: true
          if (!fallbackSet) {
            const firstFont = Object.keys(fonts)[0];
            fonts[firstFont].fallback = true;
            console.log(`[FONTS] Set ${firstFont} as fallback font`);
          }

          console.log('[FONTS] Loaded fonts:', Object.keys(fonts));
          return fonts;
        } catch (e) {
          console.warn('[FONTS] Error loading fonts:', e);
          return {};
        }
      }

      (async () => {
        try {
          // Check if user is logged in (has sessionStorage credentials or Bearer token)
          const storedToken = localStorage.getItem('EDITOR_TOKEN');
          const storedAuth = sessionStorage.getItem('auth_credentials');

          if (!storedToken && !storedAuth) {
            console.log('[INDEX] No credentials found, redirecting to login...');
            window.location.href = '/login.html';
            return;
          }

          console.log('[INDEX] Credentials found, loading editor...');

          const { uiMod, commonMod } = await loadUIAndCommon();
          const plugins = await loadSchemas();
          const customFonts = await loadCustomFonts();

          const { Designer } = uiMod;
          const { BLANK_PDF } = commonMod;

          // === API & auth ===
          const API = {
            base: location.origin,
            token: storedToken || '',
            sessionAuth: storedAuth || ''
          };
          const headers = () => {
            const h = { 'Content-Type': 'application/json' };
            // Add Bearer token if set (for API endpoints)
            if (API.token) {
              h['Authorization'] = `Bearer ${API.token}`;
            }
            // Add Basic Auth if logged in (for template endpoints)
            else if (API.sessionAuth) {
              h['Authorization'] = `Basic ${API.sessionAuth}`;
            }
            return h;
          };
          const updateAuthButtons = () => {
            const hasToken = !!API.token;
            const hasSession = !!API.sessionAuth;
            // Show "Set Token" only if no token is set
            document.getElementById('btnSetToken').style.display = hasToken ? 'none' : 'inline-block';
            // Show "Logout" if user is logged in (either via token or session)
            document.getElementById('btnLogout').style.display = (hasToken || hasSession) ? 'inline-block' : 'none';
            // Update logout button text based on auth type
            document.getElementById('btnLogout').textContent = hasToken ? 'Clear Token' : 'Logout';
          };
          document.getElementById('btnSetToken').onclick = async () => {
            const t = prompt('Paste EDITOR_AUTH_TOKEN');
            if (t && t.trim()) {
              API.token = t.trim();
              localStorage.setItem('EDITOR_TOKEN', API.token);
              updateAuthButtons();
              await refreshList();
              alert('Token set.');
            }
          };
          document.getElementById('btnLogout').onclick = async () => {
            // Clear both API token and session auth
            localStorage.removeItem('EDITOR_TOKEN');
            sessionStorage.removeItem('auth_credentials');
            API.token = '';
            API.sessionAuth = '';

            // Redirect to login page
            window.location.href = '/login.html';
          };

          // === State ===
          let currentId = null;
          let firstBasePdf = null; // Page 1 base PDF (dataURL)
          let secondBasePdf = null; // Page 2+ base PDF (dataURL)

          // === Sample JSON / variables panel ===
          const SAMPLE_JSON_KEY = 'PDFME_SAMPLE_JSON';
          const varsMetaEl = document.getElementById('varsMeta');
          const varsListEl = document.getElementById('varsList');
          const varsEmptyEl = document.getElementById('varsEmpty');
          const varsCopyInfoEl = document.getElementById('varsCopyInfo');
          const varsSearchEl = document.getElementById('varsSearch');
          const btnSetSample = document.getElementById('btnSetSample');
          const btnClearSample = document.getElementById('btnClearSample');
          let sampleData = null;
          let sampleRaw = '';
          let variablePaths = [];
          let copyInfoTimeout = null;

          const updateSampleControls = () => {
            const hasSample = !!sampleData;
            btnClearSample.disabled = !hasSample;
            varsSearchEl.disabled = !hasSample;
            if (!hasSample) varsSearchEl.value = '';
          };

          const truncatePreview = (value) => {
            if (value === null || value === undefined) return '';
            const str = String(value);
            return str.length > 80 ? `${str.slice(0, 77)}...` : str;
          };

          const extractVariablePaths = (value, basePath = '') => {
            const results = [];
            const walk = (val, currentPath) => {
              if (val === null || val === undefined) {
                if (currentPath) results.push({ path: currentPath, preview: '' });
                return;
              }
              if (typeof val === 'object') {
                if (Array.isArray(val)) {
                  if (!val.length) return;
                  const nextPath = currentPath ? `${currentPath}[0]` : '[0]';
                  walk(val[0], nextPath);
                  return;
                }
                Object.entries(val).forEach(([key, child]) => {
                  const nextPath = currentPath ? `${currentPath}.${key}` : key;
                  walk(child, nextPath);
                });
                return;
              }
              if (currentPath) results.push({ path: currentPath, preview: truncatePreview(val) });
            };
            walk(value, basePath);
            const seen = new Set();
            return results.filter((item) => {
              if (!item.path) return false;
              if (seen.has(item.path)) return false;
              seen.add(item.path);
              return true;
            });
          };

          const showCopyInfo = (msg) => {
            varsCopyInfoEl.textContent = msg;
            if (copyInfoTimeout) clearTimeout(copyInfoTimeout);
            copyInfoTimeout = setTimeout(() => {
              varsCopyInfoEl.textContent = '';
            }, 3000);
          };

          const copyPlaceholder = async (path) => {
            const text = `{{${path}}}`;
            try {
              if (navigator.clipboard?.writeText) {
                await navigator.clipboard.writeText(text);
              } else {
                const tmp = document.createElement('textarea');
                tmp.value = text;
                tmp.setAttribute('readonly', '');
                tmp.style.position = 'fixed';
                tmp.style.left = '-9999px';
                document.body.appendChild(tmp);
                tmp.select();
                document.execCommand('copy');
                tmp.remove();
              }
              showCopyInfo(`Copied ${text}`);
            } catch (err) {
              console.warn('Clipboard copy failed', err);
              alert(`Copy failed. Placeholder: ${text}`);
            }
          };

          const renderVariableList = () => {
            varsListEl.innerHTML = '';
            if (!sampleData || variablePaths.length === 0) {
              varsEmptyEl.style.display = 'block';
              varsEmptyEl.textContent = sampleData ? 'No scalar values found in sample JSON.' : 'Paste sample JSON to list placeholders.';
              varsMetaEl.textContent = sampleData ? '0 placeholders' : 'No sample JSON';
              updateSampleControls();
              return;
            }

            const filter = varsSearchEl.value.trim().toLowerCase();
            const filtered = filter
              ? variablePaths.filter((item) => item.path.toLowerCase().includes(filter) || (item.preview && item.preview.toLowerCase().includes(filter)))
              : variablePaths;

            if (!filtered.length) {
              varsEmptyEl.style.display = 'block';
              varsEmptyEl.textContent = 'No matches for search.';
            } else {
              varsEmptyEl.style.display = 'none';
              filtered.forEach((item) => {
                const btn = document.createElement('button');
                btn.type = 'button';
                btn.className = 'varsItem';
                btn.dataset.path = item.path;
                const pathEl = document.createElement('div');
                pathEl.className = 'varsPath';
                pathEl.textContent = `{{${item.path}}}`;
                btn.appendChild(pathEl);
                if (item.preview) {
                  const valEl = document.createElement('div');
                  valEl.className = 'varsValue';
                  valEl.textContent = item.preview;
                  btn.appendChild(valEl);
                }
                btn.addEventListener('click', () => copyPlaceholder(item.path));
                varsListEl.appendChild(btn);
              });
            }

            varsMetaEl.textContent = `${variablePaths.length} placeholder${variablePaths.length === 1 ? '' : 's'}`;
            updateSampleControls();
          };

          const setSampleData = (obj, rawText) => {
            sampleData = obj;
            sampleRaw = rawText;
            try {
              if (rawText) localStorage.setItem(SAMPLE_JSON_KEY, rawText);
            } catch (err) {
              console.warn('Cannot persist sample JSON', err);
            }
            if (obj && (typeof obj === 'object' || Array.isArray(obj))) {
              variablePaths = extractVariablePaths(obj);
            } else {
              variablePaths = [];
            }
            renderVariableList();
          };

          const clearSampleData = () => {
            sampleData = null;
            sampleRaw = '';
            variablePaths = [];
            localStorage.removeItem(SAMPLE_JSON_KEY);
            renderVariableList();
          };

          btnSetSample.onclick = () => {
            const initial = sampleRaw && sampleRaw.length < 2000 ? sampleRaw : '';
            const raw = prompt('Paste sample JSON (e.g. output of Parse JSON node):', initial);
            if (!raw) return;
            try {
              const parsed = JSON.parse(raw);
              setSampleData(parsed, raw);
              showCopyInfo('Sample JSON saved.');
            } catch (err) {
              console.warn('Invalid JSON sample', err);
              alert('Invalid JSON. Please paste a valid JSON object or array.');
            }
          };

          btnClearSample.onclick = () => {
            if (!sampleData) return;
            const ok = confirm('Clear stored sample JSON and variable list?');
            if (ok) {
              clearSampleData();
              showCopyInfo('Sample JSON cleared.');
            }
          };

          varsSearchEl.addEventListener('input', () => renderVariableList());

          (() => {
            const stored = localStorage.getItem(SAMPLE_JSON_KEY);
            if (stored) {
              try {
                const parsed = JSON.parse(stored);
                sampleRaw = stored;
                sampleData = parsed;
                if (parsed && (typeof parsed === 'object' || Array.isArray(parsed))) {
                  variablePaths = extractVariablePaths(parsed);
                }
              } catch (err) {
                console.warn('Stored sample JSON is invalid', err);
                localStorage.removeItem(SAMPLE_JSON_KEY);
              }
            }
            renderVariableList();
          })();

          const setCurrentId = (id) => {
            currentId = id || null;
            document.getElementById('currentId').textContent = currentId || '(none)';
            const select = document.getElementById('tplList');
            if (currentId) {
              const opt = [...select.options].find(o => o.value === currentId);
              if (opt) select.value = currentId;
            }
          };

          // === Initial template ===
          const initialTemplate = {
            basePdf: BLANK_PDF,
            schemas: [[
              { name: 'title', type: 'text', position: { x: 20, y: 20 }, width: 170, height: 15 }
            ]]
          };

          // === Utils ===
          const fileToDataUrl = async (file) => {
            const buf = await file.arrayBuffer();
            const bytes = new Uint8Array(buf);
            // Process in chunks to avoid stack overflow with large files
            const chunkSize = 8192;
            let binary = '';
            for (let i = 0; i < bytes.length; i += chunkSize) {
              const chunk = bytes.subarray(i, i + chunkSize);
              binary += String.fromCharCode(...chunk);
            }
            const b64 = btoa(binary);
            return `data:application/pdf;base64,${b64}`;
          };
          const downloadDataUrlAs = (name, dataUrl) => {
            const a = document.createElement('a');
            a.href = dataUrl; a.download = name || 'base.pdf';
            document.body.appendChild(a); a.click(); a.remove();
          };
          const setBaseStatus = (which, has) => {
            const el = document.getElementById(which === 1 ? 'base1Status' : 'base2Status');
            el.textContent = has ? 'set' : 'not set';
            el.className = 'badge ' + (has ? 'good' : 'warn');
          };

          // === Mount Designer ===
          const container = document.getElementById('container');
          const designerOptions = { zoomLevel: 1 };

          // Only add font option if custom fonts are loaded
          if (Object.keys(customFonts).length > 0) {
            designerOptions.font = customFonts;
          }

          let designer = new Designer({
            domContainer: container,
            template: initialTemplate,
            plugins, // VSE sheme po dokumentaciji
            options: designerOptions
          });

          // Initialize firstBasePdf from initial template
          firstBasePdf = initialTemplate.basePdf;

          // === API: lista in CRUD ===
          async function refreshList() {
            try {
              const res = await fetch(`${API.base}/api/templates`, { headers: headers() });
              if (!res.ok) {
                console.warn('Template list failed', res.status);
                document.getElementById('tplList').innerHTML = '';
                return;
              }
              const list = await res.json();
              const select = document.getElementById('tplList');
              select.innerHTML = '';
              for (const r of list) {
                const opt = document.createElement('option');
                opt.value = r.id; opt.textContent = `${r.name} ‚Äî ${r.id}`;
                select.appendChild(opt);
              }
              if (currentId) {
                const opt = [...select.options].find(o => o.value === currentId);
                if (opt) select.value = currentId;
              }
              // Auto-load first template if no template is currently loaded
              else if (list.length > 0 && !currentId) {
                const firstId = list[0].id;
                select.value = firstId;
                await loadTemplate(firstId);
              }
            } catch (e) { showErr(e); }
          }

          async function createTemplate() {
            const name = document.getElementById('tplName').value || 'Untitled Template';
            let template = getCompleteTemplate();
            if (secondBasePdf) {
              template._secondBasePdf = secondBasePdf;
              template._multiPageEnabled = true;
            } else {
              delete template._secondBasePdf;
              delete template._multiPageEnabled;
            }

            const res = await fetch(`${API.base}/api/templates`, {
              method: 'POST', headers: headers(), body: JSON.stringify({ name, template })
            });
            if (!res.ok) throw new Error('Create failed');
            const obj = await res.json();
            setCurrentId(obj.id);
            return obj;
          }

          async function updateTemplate(id) {
            const name = document.getElementById('tplName').value || 'Untitled Template';
            let template = getCompleteTemplate();
            if (secondBasePdf) {
              template._secondBasePdf = secondBasePdf;
              template._multiPageEnabled = true;
            } else {
              delete template._secondBasePdf;
              delete template._multiPageEnabled;
            }

            const res = await fetch(`${API.base}/api/templates/${id}`, {
              method: 'PUT', headers: headers(), body: JSON.stringify({ name, template })
            });
            if (!res.ok) throw new Error('Update failed');
            const obj = await res.json();
            setCurrentId(obj.id);
            return obj;
          }

          async function deleteTemplate(id) {
            const res = await fetch(`${API.base}/api/templates/${id}`, { method: 'DELETE', headers: headers() });
            if (res.status === 204) return true;
            if (res.status === 404) throw new Error('Template not found');
            throw new Error('Delete failed');
          }

          // === Page Layout Switch ===
          let currentEditingPage = 1; // 1 = Page 1, 2 = Page 2+
          let savedPage1Schema = []; // Store Page 1 schema when switching to Page 2
          let savedPage2Schema = []; // Store Page 2 schema when switching to Page 1

          // Check if multi-page mode is active (Page 2+ PDF is loaded)
          function isMultiPageMode() {
            return !!secondBasePdf;
          }

          // Update switch UI visibility and state
          function updatePageSwitchUI() {
            const switchDiv = document.getElementById('pageLayoutSwitch');
            const indicator = document.getElementById('currentPageIndicator');
            const btn1 = document.getElementById('btnEditPage1');
            const btn2 = document.getElementById('btnEditPage2');

            if (isMultiPageMode()) {
              switchDiv.style.display = '';
              indicator.textContent = `Editing: ${currentEditingPage === 1 ? 'Page 1' : 'Page 2+'}`;

              // Highlight active button
              if (currentEditingPage === 1) {
                btn1.style.background = '#3b82f6';
                btn1.style.color = '#ffffff';
                btn1.style.borderColor = '#2563eb';
                btn2.style.background = '#e0e7ff';
                btn2.style.color = '#000000';
                btn2.style.borderColor = '#c7d2fe';
              } else {
                btn1.style.background = '#dbeafe';
                btn1.style.color = '#000000';
                btn1.style.borderColor = '#93c5fd';
                btn2.style.background = '#6366f1';
                btn2.style.color = '#ffffff';
                btn2.style.borderColor = '#4f46e5';
              }
            } else {
              switchDiv.style.display = 'none';
              currentEditingPage = 1;
            }
          }

          // Switch to editing Page 1 or Page 2+
          function switchToPage(pageNumber) {
            if (!isMultiPageMode()) {
              alert('Upload Page 2+ base PDF first to enable multi-page layout editing.');
              return;
            }

            // Save current page schema before switching
            const currentTemplate = designer.getTemplate();
            const currentSchemas = currentTemplate.schemas || [[]];

            // Save schema from current page before switching
            if (currentEditingPage === 1 && pageNumber === 2) {
              savedPage1Schema = currentSchemas[0] || [];
            } else if (currentEditingPage === 2 && pageNumber === 1) {
              savedPage2Schema = currentSchemas[0] || [];
            }

            currentEditingPage = pageNumber;

            if (pageNumber === 1) {
              // Show only Page 1 with its PDF
              if (!firstBasePdf) {
                alert('Page 1 base PDF not found. Please reload the template.');
                return;
              }
              const page1Template = {
                ...currentTemplate,
                basePdf: firstBasePdf,
                schemas: [savedPage1Schema || []]
              };
              recreateDesigner(page1Template);
            } else {
              // Show Page 2+ alone with its PDF
              if (!secondBasePdf) {
                alert('Page 2+ base PDF not found.');
                return;
              }
              const page2Template = {
                ...currentTemplate,
                basePdf: secondBasePdf,
                schemas: [savedPage2Schema || []]
              };
              recreateDesigner(page2Template);
            }

            updatePageSwitchUI();
          }

          // Update designer template (use updateTemplate instead of recreating)
          function recreateDesigner(newTemplate) {
            // Ensure template has all required properties
            const validTemplate = {
              basePdf: newTemplate.basePdf,
              schemas: newTemplate.schemas || [[]],
              // Preserve other template properties if they exist
              ...(newTemplate.sampledata && { sampledata: newTemplate.sampledata }),
              ...(newTemplate.columns && { columns: newTemplate.columns })
            };

            try {
              designer.updateTemplate(validTemplate);
            } catch (err) {
              console.error('[DESIGNER] Failed to update template:', err);
              alert('Failed to switch pages: ' + err.message);
            }
          }

          // Get complete template (merge all pages for saving)
          function getCompleteTemplate() {
            const template = designer.getTemplate();

            // If in multi-page mode, build complete template with both pages
            if (isMultiPageMode()) {
              const currentSchemas = template.schemas || [[]];

              // Build complete schemas array (Page 1 + Page 2)
              let page1Schema, page2Schema;

              if (currentEditingPage === 1) {
                // Currently editing Page 1
                page1Schema = currentSchemas[0] || [];
                page2Schema = savedPage2Schema || [];
              } else {
                // Currently editing Page 2
                page1Schema = savedPage1Schema || [];
                page2Schema = currentSchemas[0] || [];
              }

              // Return complete template with both pages (basePdf array for Generator)
              return {
                ...template,
                basePdf: [firstBasePdf, secondBasePdf],
                schemas: [page1Schema, page2Schema]
              };
            }

            return template;
          }

          // === UI handlers ===
          document.getElementById('btnNew').onclick = () => {
            designer.updateTemplate(initialTemplate);
            document.getElementById('tplName').value = '';
            firstBasePdf = null;
            secondBasePdf = null;
            setBaseStatus(1, false);
            setBaseStatus(2, false);
            currentEditingPage = 1;
            savedPage1Schema = [];
            savedPage2Schema = [];
            updatePageSwitchUI();
            setCurrentId(null);
          };

          document.getElementById('btnSave').onclick = async () => {
            try {
              if (currentId) await updateTemplate(currentId); else await createTemplate();
              await refreshList();
              // Auto-detect variables after save
              document.getElementById('btnDetectVars').click();
              alert('Saved!');
            } catch (e) { showErr(e); alert(e.message || 'Save failed'); }
          };

          document.getElementById('btnSaveAs').onclick = async () => {
            try {
              setCurrentId(null);
              await createTemplate();
              await refreshList();
              alert('Saved as new template!');
            } catch (e) { showErr(e); alert(e.message || 'Save As failed'); }
          };

          document.getElementById('btnDuplicate').onclick = async () => {
            try {
              if (!currentId) {
                alert('No template loaded. Load a template first to duplicate it.');
                return;
              }

              // Get current template name and add " (Copy)" suffix
              const currentName = document.getElementById('tplName').value || 'Untitled Template';
              const newName = `${currentName} (Copy)`;

              // Update name field
              document.getElementById('tplName').value = newName;

              // Clear current ID to force creation of new template
              setCurrentId(null);

              // Create new template with all current data
              await createTemplate();
              await refreshList();

              alert('Template duplicated successfully!');
            } catch (e) {
              showErr(e);
              alert(e.message || 'Duplicate failed');
            }
          };

          // Load template function (extracted for reuse)
          const loadTemplate = async (id) => {
            if (!id) return;
            try {
              const res = await fetch(`${API.base}/api/templates/${id}`, { headers: headers() });
              if (!res.ok) {
                alert('Load failed');
                return;
              }
              const { name, template, id: loadedId } = await res.json();
              document.getElementById('tplName').value = name;

              // Extract base PDFs
              secondBasePdf = typeof template._secondBasePdf === 'string' ? template._secondBasePdf : null;
              firstBasePdf = Array.isArray(template.basePdf) ? template.basePdf[0] : template.basePdf;

              setBaseStatus(1, !!firstBasePdf);
              setBaseStatus(2, !!secondBasePdf);

              // Load template - if multi-page mode, start on Page 1
              currentEditingPage = 1;
              const schemas = template.schemas || [[]];

              if (isMultiPageMode()) {
                // Initialize saved schemas from loaded template
                savedPage1Schema = schemas.length >= 1 ? schemas[0] : [];
                savedPage2Schema = schemas.length >= 2 ? schemas[1] : [];

                // Show only Page 1 initially
                const page1Template = {
                  ...template,
                  basePdf: firstBasePdf,
                  schemas: [savedPage1Schema]
                };
                designer.updateTemplate(page1Template);
              } else {
                // Single page mode
                savedPage1Schema = [];
                savedPage2Schema = [];
                designer.updateTemplate(template);
              }

              updatePageSwitchUI();
              setCurrentId(loadedId || id);
            } catch (e) {
              showErr(e);
              alert('Load failed: ' + (e.message || e));
            }
          };

          // Auto-load on dropdown change
          document.getElementById('tplList').onchange = async () => {
            const id = document.getElementById('tplList').value;
            await loadTemplate(id);
          };

          // Load button (kept for manual reload if needed)
          document.getElementById('btnLoad').onclick = async () => {
            const id = document.getElementById('tplList').value;
            await loadTemplate(id);
          };

          document.getElementById('btnDelete').onclick = async () => {
            try {
              if (!currentId) return alert('Ni izbranega template-a (Current ID je prazen).');
              const currentName = document.getElementById('tplName').value || '(unnamed)';
              const sure = confirm(`Res ≈æeli≈° izbrisati template?\n\nName: ${currentName}\nID: ${currentId}`);
              if (!sure) return;
              await deleteTemplate(currentId);
              setCurrentId(null);
              document.getElementById('tplName').value = '';
              designer.updateTemplate(initialTemplate);
              firstBasePdf = null;
              secondBasePdf = null;
              setBaseStatus(1, false);
              setBaseStatus(2, false);
              currentEditingPage = 1;
              savedPage1Schema = [];
              savedPage2Schema = [];
              updatePageSwitchUI();
              await refreshList();
              alert('Deleted.');
            } catch (e) { showErr(e); alert(e.message || 'Delete failed'); }
          };

          document.getElementById('btnPreview').onclick = async () => {
            try {
              const t = designer.getTemplate();
              if (secondBasePdf) t._secondBasePdf = secondBasePdf; else delete t._secondBasePdf;
              // dva vnosa -> 2 strani -> na drugi se uporabi Page 2+ base
              const inputs = [ { title: 'Hello from PDFme' }, { title: 'Second page' } ];
              const res = await fetch(`${API.base}/api/render`, {
                method: 'POST', headers: headers(), body: JSON.stringify({ template: t, inputs, fileName: 'preview' })
              });
              if (!res.ok) return alert('Preview failed');
              const blob = await res.blob();
              const url = URL.createObjectURL(blob);
              window.open(url, '_blank');
            } catch (e) { showErr(e); alert('Preview error'); }
          };

          // Base PDF gumbi
          document.getElementById('btnBase1Upload').onclick = async () => {
            const f = document.getElementById('base1File').files?.[0];
            if (!f) return alert('Izberi PDF datoteko.');
            const dataUrl = await fileToDataUrl(f);
            firstBasePdf = dataUrl;  // Store in variable
            const tpl = designer.getTemplate();
            tpl.basePdf = dataUrl;
            designer.updateTemplate(tpl);
            setBaseStatus(1, true);
            alert('Base PDF (page 1) set.');
          };
          document.getElementById('btnBase1Clear').onclick = () => {
            const tpl = designer.getTemplate();
            tpl.basePdf = BLANK_PDF;
            designer.updateTemplate(tpl);
            setBaseStatus(1, false);
          };
          document.getElementById('btnBase1Download').onclick = () => {
            const tpl = designer.getTemplate();
            if (typeof tpl.basePdf === 'string') {
              const name = (document.getElementById('tplName').value || 'template') + '_base_page1.pdf';
              downloadDataUrlAs(name, tpl.basePdf);
            } else {
              alert('Ni nastavljenega Base PDF (page 1).');
            }
          };

          document.getElementById('btnBase2Upload').onclick = async () => {
            const f = document.getElementById('base2File').files?.[0];
            if (!f) return alert('Izberi PDF datoteko.');
            secondBasePdf = await fileToDataUrl(f);
            setBaseStatus(2, true);
            updatePageSwitchUI();  // Show page switch buttons
            alert('Second-page Base PDF set.');
          };
          document.getElementById('btnBase2Clear').onclick = () => {
            secondBasePdf = null;
            setBaseStatus(2, false);
            currentEditingPage = 1;
            updatePageSwitchUI();  // Hide page switch buttons
          };
          document.getElementById('btnBase2Download').onclick = () => {
            if (secondBasePdf) {
              const name = (document.getElementById('tplName').value || 'template') + '_base_page2plus.pdf';
              downloadDataUrlAs(name, secondBasePdf);
            } else {
              alert('Ni nastavljenega Second-page Base PDF.');
            }
          };

          // Detect Variables in Template
          let detectedVariables = [];

          const detectTemplateVariables = () => {
            const template = designer.getTemplate();
            const schemas = template.schemas || [];
            const varSet = new Set();

            // Scan all pages and schemas
            schemas.forEach((pageSchemas) => {
              if (!Array.isArray(pageSchemas)) return;
              pageSchemas.forEach((schema) => {
                // Check 'content' field (multiVariableText, text)
                if (schema.content && typeof schema.content === 'string') {
                  const matches = schema.content.matchAll(/\{\{([^}]+)\}\}/g);
                  for (const match of matches) {
                    varSet.add(match[1].trim());
                  }
                }
                // Check 'text' field (legacy text schemas)
                if (schema.text && typeof schema.text === 'string') {
                  const matches = schema.text.matchAll(/\{\{([^}]+)\}\}/g);
                  for (const match of matches) {
                    varSet.add(match[1].trim());
                  }
                }
              });
            });

            detectedVariables = Array.from(varSet).sort();
            return detectedVariables;
          };

          document.getElementById('btnDetectVars').onclick = () => {
            const vars = detectTemplateVariables();
            const detectedVarsEl = document.getElementById('detectedVars');
            const btnCopyConfig = document.getElementById('btnCopyN8nConfig');

            if (vars.length === 0) {
              detectedVarsEl.textContent = 'No variables found. Add fields with {{variableName}} syntax.';
              detectedVarsEl.style.color = '#dc2626';
              btnCopyConfig.disabled = true;
            } else {
              detectedVarsEl.innerHTML = `Found <strong>${vars.length}</strong> variable${vars.length === 1 ? '' : 's'}: <code>${vars.join('</code>, <code>')}</code>`;
              detectedVarsEl.style.color = '#166534';
              btnCopyConfig.disabled = false;
            }
          };

          document.getElementById('btnCopyN8nConfig').onclick = async () => {
            if (detectedVariables.length === 0) {
              alert('No variables detected. Click "Detect Variables" first.');
              return;
            }

            // Prompt user to mark which variable is the AI text
            const aiVarPrompt = detectedVariables.length === 1
              ? `The only variable is: ${detectedVariables[0]}\n\nIs this the AI text variable?`
              : `Which variable contains AI text?\n\nOptions:\n${detectedVariables.map((v, i) => `${i + 1}. ${v}`).join('\n')}\n\nEnter number (or leave empty if none):`;

            let aiVar = null;
            if (detectedVariables.length === 1) {
              const isAi = confirm(aiVarPrompt);
              if (isAi) aiVar = detectedVariables[0];
            } else {
              const answer = prompt(aiVarPrompt);
              if (answer && answer.trim()) {
                const idx = parseInt(answer.trim()) - 1;
                if (idx >= 0 && idx < detectedVariables.length) {
                  aiVar = detectedVariables[idx];
                }
              }
            }

            // Generate n8n config
            const config = {
              templateId: currentId || '(save template first)',
              aiTextVariable: aiVar || '(none - all from Input 1)',
              otherVariables: aiVar ? detectedVariables.filter(v => v !== aiVar) : detectedVariables,
              instructions: {
                step1: 'In n8n PDFMe Render node, set Mode: Simple',
                step2: aiVar ? `Set "AI Text Variable Name" to: ${aiVar}` : 'No AI variable - set all via Input 1',
                step3: 'Connect data sources:',
                input1: aiVar ? `Input 1: Structured data (${detectedVariables.filter(v => v !== aiVar).join(', ')})` : `Input 1: All data (${detectedVariables.join(', ')})`,
                input2: aiVar ? `Input 2: OpenAI Assistant output (field: "output")` : 'Input 2: (not needed)',
                step4: 'Set "Additional Variables Mapping" to: Auto-merge all Input 1 fields'
              }
            };

            const configJson = JSON.stringify(config, null, 2);

            try {
              if (navigator.clipboard?.writeText) {
                await navigator.clipboard.writeText(configJson);
              } else {
                const tmp = document.createElement('textarea');
                tmp.value = configJson;
                tmp.setAttribute('readonly', '');
                tmp.style.position = 'fixed';
                tmp.style.left = '-9999px';
                document.body.appendChild(tmp);
                tmp.select();
                document.execCommand('copy');
                tmp.remove();
              }
              alert(`‚úÖ n8n Config copied to clipboard!\n\nVariables: ${detectedVariables.join(', ')}\nAI Variable: ${aiVar || 'none'}\n\nPaste this config in your notes for reference.`);
            } catch (err) {
              console.error('Copy failed', err);
              prompt('Copy this n8n config manually:', configJson);
            }
          };

          // Quick Add AI Text Field
          document.getElementById('btnQuickAiField').onclick = () => {
            const varName = prompt(
              'Enter variable name for AI text (will be used as {{variableName}} in template):\n\n' +
              'Examples: content, aiText, analysis, summary\n\n' +
              'Use the SAME name in n8n Render node\'s "AI Text Variable Name" setting.',
              'content'
            );
            if (!varName || !varName.trim()) return;

            const cleanName = varName.trim();
            const template = designer.getTemplate();
            const schemas = template.schemas || [[]];
            const firstPage = schemas[0] || [];

            // Check if field already exists
            const exists = firstPage.some(s => s.content && s.content.includes(`{{${cleanName}}}`));
            if (exists) {
              alert(`A field with variable {{${cleanName}}} already exists in template.`);
              return;
            }

            // Add multiVariableText field with the variable
            const newField = {
              type: 'multiVariableText',
              content: `{{${cleanName}}}`,
              position: { x: 20, y: 60 },
              width: 170,
              height: 200,
              fontSize: 11,
              lineHeight: 1.5,
              alignment: 'left',
              fontColor: '#000000',
              characterSpacing: 0,
              fontName: 'NotoSerifJP'
            };

            firstPage.push(newField);
            template.schemas[0] = firstPage;
            designer.updateTemplate(template);

            alert(
              `‚úÖ Added multiVariableText field with {{${cleanName}}}\n\n` +
              `Next steps:\n` +
              `1. Position and resize the field in the designer\n` +
              `2. In n8n Render node, set "AI Text Variable Name" to: ${cleanName}\n` +
              `3. OpenAI Assistant text will automatically fill this field`
            );
          };

          // Page Layout Switch button handlers
          document.getElementById('btnEditPage1').onclick = () => {
            switchToPage(1);
          };

          document.getElementById('btnEditPage2').onclick = () => {
            switchToPage(2);
          };

          // Init
          updateAuthButtons();
          setCurrentId(null);
          setBaseStatus(1, false);
          setBaseStatus(2, false);
          currentEditingPage = 1;
          updatePageSwitchUI();
          document.getElementById('tplName').value = '';
          refreshList();
        } catch (e) {
          showErr(e);
        }
      })();
    </script>
  </body>
</html>
